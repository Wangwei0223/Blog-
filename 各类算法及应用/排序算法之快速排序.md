### 快速排序及其JS实现
![](https://upload-images.jianshu.io/upload_images/1867034-cd65e35d7dce5045.gif?imageMogr2/auto-orient/)
>快速排序.gif

快速排序, 面试基本必考. 为什么必考呢? 就是别看他很常见, 能写明白的人不多...裸写快速排序, 真滴需要点水平.

原理摘抄, 修改至此. [坐在马桶上看算法之快速排序](http://developer.51cto.com/art/201403/430986.htm)

假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：

3  1  2 5  4  6  9 7  10  8

在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？

方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。
![](http://s9.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNWg3HhPAAAfgmnJY0E832.jpg-wh_651x-s_2122757912.jpg)

首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。
![](http://s3.51cto.com/wyfs02/M00/1A/00/wKioL1MUSNbjWRw9AAAfljx73DY807.jpg)
![](http://s9.51cto.com/wyfs02/M00/19/FF/wKiom1MUSP7gBX4VAAAaPLt4QB0783.jpg)
现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6  1  2  5  9 3  4  7  10  8
![](http://s7.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQCzWy0UAAAe9Ihqgcs108.jpg)
![](http://s7.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQOCyGOFAAAbW4sRFRs031.jpg)
到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：

6  1  2 5  4  3  9  7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

3  1 2  5  4  6  9 7  10  8
![](http://s2.51cto.com/wyfs02/M01/19/FF/wKiom1MUSQWiPameAAAawpa4u98529.jpg)
![](http://s3.51cto.com/wyfs02/M02/19/FF/wKiom1MUSQizZS4AAAAg4BoYKU8539.jpg)
![](http://s3.51cto.com/wyfs02/M00/19/FF/wKiom1MUSQqSkSkpAAAchtx6GUg755.jpg)
到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧

如果你模拟的没有错，调整完毕之后的序列的顺序应该是：

2  1  3  5  4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：
1  2  3 4  5  6 9  7  10  8

对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下

1  2  3 4  5  6  7  8 9  10

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了

**废话不说, 上代码具体对着上面的步骤去看**
```javascript
function QuickSort(arr) {
    	return Quick(arr, 0, arr.length - 1); // 基准的两个守卫 0 和 arr.length - 1
}

function Quick(arr, left, right) {
    var index;
    if (left < right) {
        	index = partition(arr, left, right); // 返回第一个守卫的位置
			if (left < index - 1) {
				Quick(arr, left, index - 1);  //继续划分子空间递归
			}
			if (right > index) {
				Quick(arr, index, right); //继续划分子空间递归
			}
    }
    	return arr;
}

function partition(arr, left, right) {
    const pivot = arr[Math.floor((left + right) / 2)]; // 找到基准值
    var i = left, j = right; // 初始化左右守卫
    while (i <= j) {
			while (arr[i] < pivot) { //找到第一个要交换的值
				i++;
			}
			while (arr[j] > pivot) { //找到第一个要交换的值
				j--;
			}
			if (i <= j) {
				[arr[i], arr[j]] = [arr[j], arr[i]]; //判断是否要交换
				i++;
				j--;
			}
    }
    return i;
}

console.log(QuickSort([2, 3, 6, 8, 2, 4, 5, 63, 45, 63, 2, 3, 53, 3]))
```

### 关于快速排序, 圈内比较有趣的争议

阮一峰老师的快速排序曾经在微博上引起一阵讨论, 现在搜"阮一峰版的快速排序其实是错的"还能看见很多讨论

先看一下阮一峰老师的版本, 可以先不下划看我的结论, 想想具体哪些地方不合适(不能说不对, 因为代码是没有错误的)
```javascript
var quickSort = function(arr) {
　　if (arr.length <= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat([pivot], quickSort(right));
};
```
具体的不合适在哪?
个人拙见如下, 大家也可以去网上具体查看不同的说法.
1. splice()费时, 但是为什么用splice()? 就是为了最后的拼接...要单独把pivot取出来, 所以这么写
2. 每次都要开辟 left 和 right两个新数组吗? 精髓是交换吧, 用交换的话还需要开辟新空间吗?
3. 面试官肯定不会买帐的写法, 因为没有体现快速排序的算法.